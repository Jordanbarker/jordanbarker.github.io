<html>
<head>
<title>minimal demo</title>
<style>
    body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 90vh;
        margin: 0;
        background-color: black;
    }
    #pongCanvas {
        background-color: #333;
        border: 2px solid #fff;
        width: 100%;
        max-width: 800px;
        height: 40vh;
    }
    #scoreboard {
        display: flex;
        justify-content: space-around;
        width: 100%;
        max-width: 800px;
        color: #333;
        font-size: 20px;
        font-weight: bold;
        margin-top: 50px;
    }
    #chart-container, #button-container {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        max-width: 800px;
        margin-top: 10px;
    }
    #chart-container canvas, #button-container button {
        margin: 0 10px;
    }
</style>

</head>
<body>
<!-- <body onload="start()"> -->
<div id="egdiv"></div>
<div id="scoreboard">
    <div id="playerScore">Player: 0</div>
    <div id="computerScore">Computer: 0</div>
</div>
<canvas id="pongCanvas" width="800" height="400"></canvas>
<div id="chart-container">
    <canvas id="lineChart"></canvas>
</div>
<div id="button-container">
    <button onclick="savenet()">Save Network</button>
    <input type="file" id="fileInput" accept=".json">
    <button onclick="loadnet()">Load Network</button>
    <!-- <textarea id="tt"></textarea> -->
    <textarea id="tt" style="display:none;"></textarea>
</div>
</body>

<script src="convnetjs/convnet-min.js"></script>
<script src="convnetjs/util.js"></script>
<script src="convnetjs/deepqlearn.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    const ctx = document.getElementById('lineChart').getContext('2d');
    const lineChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Average Reward',
                    data: [],
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderWidth: 2,
                    fill: false
                }
            ]
        },
        options: {
            animation: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Time'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Value'
                    }
                }
            }
        }
    });

    function addData() {
        const currentTime = new Date().toLocaleTimeString()
        lineChart.data.labels.push(currentTime);
        lineChart.data.datasets[0].data.push(brain.average_reward_window.sum / brain.average_reward_window.size);
        lineChart.update();
    }

    
    
    // RL Agent Settings
    var num_inputs = 3; // ball.x, ball.y, computer.y
    var num_actions = 3; // up, down, stay
    var temporal_window = 1; // amount of temporal memory. 0 = agent lives in-the-moment :)
    var network_size = num_inputs*temporal_window + num_actions*temporal_window + num_inputs;
    var layer_defs = [];
        layer_defs.push({type:'input', out_sx:1, out_sy:1, out_depth:network_size});
        layer_defs.push({type:'fc', num_neurons: 10, activation:'relu'});
        layer_defs.push({type:'fc', num_neurons: 10, activation:'relu'});
        // layer_defs.push({type:'fc', num_neurons: 50, activation:'relu'});
        layer_defs.push({type:'regression', num_neurons:num_actions});

    var opt = {};
        opt.temporal_window = temporal_window;
        opt.experience_size = 300000;
        opt.start_learn_threshold = 0;
        // opt.start_learn_threshold = 1000;
        opt.gamma = 0.99;
        // opt.learning_steps_total = 2000000;
        // opt.learning_steps_burnin = 3000;
        opt.learning_steps_burnin = 0;
        opt.epsilon_min = 0.1;
        // opt.epsilon_test_time = 0.05;
        opt.layer_defs = layer_defs;
        opt.tdtrainer_options = {learning_rate:0.01, momentum:0.0, batch_size: 32, l2_decay:0.1};
    var brain = new deepqlearn.Brain(num_inputs, num_actions, opt);
    var action = 0; // globally scope 
    var reward = 0;

    // Game settings
    const framerate = 10000; // frames per second
    const intervalTime = 1000 / framerate;
    const paddleWidth = 10;
    const paddleHeight = 100;
    const gameSpeed = 5;
    const paddleSpeed = gameSpeed;
    const ballSpeed = gameSpeed;

    function savenet() {
        var json = brain.value_net.toJSON();
        var text = JSON.stringify(json);
        document.getElementById('tt').value = text;

        var blob = new Blob([text], { type: 'application/json' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'pong_agent_network.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
    
    function loadnet() {
        //   var text = document.getElementById('tt').value;
        //   var json = JSON.parse(text);
        //   brain.value_net.fromJSON(json);
        var fileInput = document.getElementById('fileInput');
        var file = fileInput.files[0];
        var reader = new FileReader();
        
        reader.onload = function(e) {
            var text = e.target.result;
            var json = JSON.parse(text);
            brain.value_net.fromJSON(json);
        };
                
        reader.readAsText(file);
        console.log("Network Loaded Sucesssfully!")
    }

    const canvas = document.getElementById("pongCanvas");
    const context = canvas.getContext("2d");

    function resizeCanvas() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const playerPaddle = {
        x: 10,
        y: (canvas.height - paddleHeight) / 2,
        width: paddleWidth,
        height: paddleHeight,
        dy: 0
    };

    const computerPaddle = {
        x: canvas.width - paddleWidth - 10,
        y: (canvas.height - paddleHeight) / 2,
        width: paddleWidth,
        height: paddleHeight,
        dy: 5
    };

    const ball = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 7,
        dx: ballSpeed,
        dy: ballSpeed
    };

    let playerScore = 0;
    let computerScore = 0;
    const playerScoreElement = document.getElementById("playerScore");
    const computerScoreElement = document.getElementById("computerScore");

    function drawRect(x, y, width, height, color) {
        context.fillStyle = color;
        context.fillRect(x, y, width, height);
    }

    function drawCircle(x, y, radius, color) {
        context.fillStyle = color;
        context.beginPath();
        context.arc(x, y, radius, 0, Math.PI * 2);
        context.closePath();
        context.fill();
    }

    function movePaddles() {
        playerPaddle.y += playerPaddle.dy;

        if (playerPaddle.y < 0) {
            playerPaddle.y = 0;
        } else if (playerPaddle.y + paddleHeight > canvas.height) {
            playerPaddle.y = canvas.height - paddleHeight;
        }

        // Normalize each dimension to [-1, 1]
        // console.log((ball.x / canvas.height),(ball.y / canvas.width), (computerPaddle.y / canvas.height))
        action = brain.forward([(ball.x / canvas.height), (ball.y / canvas.width), (computerPaddle.y / canvas.height)]);
        // action = brain.forward([ball.x, ball.y, computerPaddle.y]);
        if (action == 1) {
            computerPaddle.y += paddleSpeed;
        } else if (action == 2) {
            computerPaddle.y -= paddleSpeed;
        }
        // Else do nothing 

        if (computerPaddle.y < 0) {
            computerPaddle.y = 0
        } else if (computerPaddle.y + paddleHeight > canvas.height) {
            computerPaddle.y = canvas.height - paddleHeight;
        }
        // console.log(action)
    }

    function moveBall() {
        ball.x += ball.dx;
        ball.y += ball.dy;
        reward = (action == 0) ? 0.5: -0.5 // Penalize twitchy behavior
        reward = 0
        // console.log(action, reward)
        // console.log("ball", ball.x - ball.radius)

        if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
            ball.dy *= -1;
        }
        if (ball.x - ball.radius < 15) {
            computerScore++;
            updateScore();
            resetBall();
        } else if (ball.x + ball.radius > canvas.width - 15) {
            reward = -1.0 // Negative reward for failing to hit the ball
            playerScore++;
            updateScore();
            resetBall();
        } else if (ball.x + ball.radius > computerPaddle.x &&
            ball.y > computerPaddle.y &&
            ball.y < computerPaddle.y + computerPaddle.height) 
        {
            ball.dx *= -1;
            reward = 1.0; // Reward hitting the ball
        } else if (ball.x - ball.radius < playerPaddle.x + playerPaddle.width &&
            ball.y > playerPaddle.y &&
            ball.y < playerPaddle.y + playerPaddle.height)
        {
            ball.dx *= -1;
        }

        
        // console.log(reward)
        brain.backward(reward);
        if (Math.random() > 0.9999) {
            console.log(brain)
            addData()
        }

    }

    function resetBall() {
        ball.x = canvas.width / 2;
        ball.y = canvas.height / 2;
        ball.dx *= -1;
    }

    function updateScore() {
        playerScoreElement.textContent = `Player: ${playerScore}`;
        computerScoreElement.textContent = `Computer: ${computerScore}`;
    }

    function draw() {
        context.clearRect(0, 0, canvas.width, canvas.height);
        drawRect(playerPaddle.x, playerPaddle.y, playerPaddle.width, playerPaddle.height, "#FFF");
        drawRect(computerPaddle.x, computerPaddle.y, computerPaddle.width, computerPaddle.height, "#FFF");
        drawCircle(ball.x, ball.y, ball.radius, "#FFF");
    }

    function update() {
        movePaddles();
        moveBall();
    }

    function gameLoop() {
        update();
        draw();
    }

    document.addEventListener("keydown", (event) => {
        if (event.key === "ArrowUp") {
            playerPaddle.dy = -paddleSpeed;
        } else if (event.key === "ArrowDown") {
            playerPaddle.dy = paddleSpeed;
        }
    });

    document.addEventListener("keyup", () => {
        playerPaddle.dy = 0;
    });

    setInterval(gameLoop, intervalTime);

    </script>
</html>
