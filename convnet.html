<html>
<head>
<title>Agent 1</title>
<style>
    body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 190vh;
        margin: 0;
        background-color: rgb(242, 239, 239);
    }
    #pongCanvas {
        background-color: #333;
        border: 2px solid #fff;
        width: 100%;
        max-width: 800px;
        height: 40vh;
    }
    #scoreboard {
        display: flex;
        justify-content: space-around;
        width: 100%;
        max-width: 800px;
        color: #333;
        font-size: 20px;
        font-weight: bold;
        margin-top: 50px;
    }
    #chart-container, #button-container {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        max-width: 800px;
        margin-top: 10px;
    }
    #chart-container canvas, #button-container button {
        margin: 0 10px;
    }
    .label {
        /* fill: white; */
        text-anchor: middle;
    }
    .description {
        fill: black;
        text-anchor: middle;
    }
    #brain-attributes {
        text-decoration: none;
    }

</style>

</head>
<body>
<!-- <body onload="start()"> -->
<!-- <div id="networkChart"></div> -->
<!-- <div id="egdiv"></div> -->
<div id="scoreboard">
    <div id="playerScore">Player: 0</div>
    <div id="computerScore">Computer: 0</div>
</div>
<canvas id="pongCanvas" width="800" height="400" tabindex="0"></canvas>
<div id="controls">
    <button onclick="setFrameRate(1)">1 FPS</button>
    <button onclick="setFrameRate(10)">10 FPS</button>
    <button onclick="setFrameRate(60)">60 FPS</button>
    <button onclick="setFrameRate(1000)">1000 FPS</button>
</div>
<div id="brain-attributes"></div>
<div id="chart-container"><canvas id="rewardChart"></canvas></div>
<div id="chart-container"><canvas id="lossChart"></canvas></div>
<div id="chart-container"><canvas id="actionChart"></canvas></div>

<div id="button-container">
    <button onclick="savenet()">Save Network</button>
    <input type="file" id="fileInput" accept=".json">
    <button onclick="loadnet()">Load Network</button>
    <!-- <textarea id="tt"></textarea> -->
    <textarea id="tt" style="display:none;"></textarea>
</div>
</body>

<script src="convnetjs/convnet-min.js"></script>
<script src="convnetjs/util.js"></script>
<script src="convnetjs/deepqlearn.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    const rewardChart = new Chart(document.getElementById('rewardChart').getContext('2d'), {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Average Reward',
                    data: [],
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderWidth: 2,
                    fill: false
                }
            ]
        },
        options: {
            animation: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Time'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Value'
                    }
                }
            }
        }
    });
    const lossChart = new Chart(document.getElementById('lossChart').getContext('2d'), {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Average Loss',
                    data: [],
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderWidth: 2,
                    fill: false
                }
            ]
        },
        options: {
            animation: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Time'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Value'
                    }
                }
            }
        }
    });

    const actionChart = new Chart(document.getElementById('actionChart').getContext('2d'), {
        type: 'bar',
        data: {
            labels: ["Stay", "Up", "Down"],
            datasets: [{
                label: 'Value',
                data: [.0001, .0001, .0001],
                borderColor: 'black',
                borderWidth: 1
            }]
        },
        options: {
            animation: false,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function(value) {
                            return value.toFixed(4);
                        }
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        label: function(tooltipItem) {
                            return tooltipItem.raw.toFixed(2);
                        }
                    }
                }
            }
        }
    });

    function updateActionChart() {

        data = [brain.value_net.layers[brain.value_net.layers.length-1].out_act.w[0], 
                brain.value_net.layers[brain.value_net.layers.length-1].out_act.w[1], 
                brain.value_net.layers[brain.value_net.layers.length-1].out_act.w[2]]

        actionChart.data.datasets[0].data = data;
        actionChart.data.datasets[0].backgroundColor = data.map(value => {
            const max = Math.max(...data);
            const min = Math.min(...data);
            const ratio = (value - min) / (max - min);
            const blueValue = Math.floor(255 * ratio);
            return `rgb(${255 - blueValue}, ${255 - blueValue}, 255)`;
        });

        actionChart.update();
    }

    function addData() {
        const currentTime = new Date().toLocaleTimeString()
        rewardChart.data.labels.push(currentTime);
        // console.log(brain.average_reward_window)
        rewardChart.data.datasets[0].data.push(brain.average_reward_window.sum / brain.average_reward_window.size);
        rewardChart.update();

        lossChart.data.labels.push(currentTime);
        lossChart.data.datasets[0].data.push(brain.average_loss_window.sum / brain.average_loss_window.v.length);
        lossChart.update();

        updateActionChart()

        const brainAttributes = [
            `age: ${brain.age}`,
            `epsilon: ${brain.epsilon.toFixed(3)}`,
        ];

        const brainAttributesList = brainAttributes.map(attr => `<li>${attr}</li>`).join('');
            
        document.getElementById('brain-attributes').innerHTML = `<ul>${brainAttributesList}</ul>`;
    }

    
    
    // RL Agent Settings
    var num_inputs = 5; // ball.x, ball.y, ball.dx, ball.dy, computer.y
    var num_actions = 3; // up, down, stay
    var temporal_window = 1; // amount of temporal memory. 0 = agent lives in-the-moment :)
    var network_size = num_inputs*temporal_window + num_actions*temporal_window + num_inputs;
    var layer_defs = [];
        layer_defs.push({type:'input', out_sx:1, out_sy:1, out_depth:network_size});
        layer_defs.push({type:'fc', num_neurons: 16, activation:'relu'});
        layer_defs.push({type:'fc', num_neurons: 10, activation:'relu'});
        layer_defs.push({type:'fc', num_neurons: 6, activation:'relu'});
        layer_defs.push({type:'regression', num_neurons:num_actions});

    var opt = {};
        opt.temporal_window = temporal_window;
        opt.experience_size = 50000;
        // opt.start_learn_threshold = 0;
        opt.start_learn_threshold = 1000;
        opt.gamma = 0.9;
        opt.learning_steps_total = 500000;
        opt.learning_steps_burnin = 1000;
        // opt.learning_steps_burnin = 0;
        opt.epsilon_min = 0.05;
        opt.epsilon_test_time = 0.0; // No random moves when learning == False
        opt.layer_defs = layer_defs;
        // opt.tdtrainer_options = {learning_rate:0.005, momentum:0.01, batch_size: 16, l2_decay:0.1, eps:.001};
        opt.tdtrainer_options = {learning_rate:0.005, momentum:0.01, batch_size: 8, l2_decay:0.1};
    var brain = new deepqlearn.Brain(num_inputs, num_actions, opt);
    var action = 0; // globally scope 
    var reward = 0;

    // Game settings
    let fps = 10000; // frames per second
    let intervalTime = 1000 / fps;
    const paddleWidth = 10;
    const paddleHeight = 100;
    const gameSpeed = 5;
    const paddleSpeed = gameSpeed;
    const ballSpeed = gameSpeed;
    var frame = 0

    function setFrameRate(fps) {
        // if (gameLoopInterval) {
        clearInterval(gameLoopInterval);
        // }
        intervalTime = 1000 / fps;
        gameLoopInterval = setInterval(gameLoop, intervalTime);
    }

    function savenet() {
        var json = brain.value_net.toJSON();
        var text = JSON.stringify(json);
        document.getElementById('tt').value = text;

        var blob = new Blob([text], { type: 'application/json' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'pong_agent_network.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
    
    function loadnet() {
        //   var text = document.getElementById('tt').value;
        //   var json = JSON.parse(text);
        //   brain.value_net.fromJSON(json);
        var fileInput = document.getElementById('fileInput');
        var file = fileInput.files[0];
        var reader = new FileReader();
        
        reader.onload = function(e) {
            var text = e.target.result;
            var json = JSON.parse(text);
            brain.value_net.fromJSON(json);
        };
                
        reader.readAsText(file);
        console.log("Network Loaded Sucesssfully!")
    }

    const canvas = document.getElementById("pongCanvas");
    const context = canvas.getContext("2d");

    function resizeCanvas() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const playerPaddle = {
        x: 10,
        y: (canvas.height - paddleHeight) / 2,
        width: paddleWidth,
        height: paddleHeight,
    };

    const computerPaddle = {
        x: canvas.width - paddleWidth - 10,
        y: (canvas.height - paddleHeight) / 2,
        width: paddleWidth,
        height: paddleHeight,
    };

    const ball = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 7,
        dx: ballSpeed,
        dy: ballSpeed
    };

    function update() { 
        frame += 1

        //
        // Move Paddles
        //

        // playerPaddle.y += playerPaddle.dy;
        // if (playerPaddle.y < 0) {
        //     playerPaddle.y = 0;
        // } else if (playerPaddle.y + paddleHeight > canvas.height) {
        //     playerPaddle.y = canvas.height - paddleHeight;
        // }
        if (playerPaddle.y + playerPaddle.height / 2 < ball.y) {
            playerPaddle.y += paddleSpeed;
        } else {
            playerPaddle.y -= paddleSpeed;
        }


        inputs = [
            4 * ((ball.x / canvas.width) - 0.5), 
            4 * ((ball.y / canvas.height) - 0.5), 
            (ball.dx / ballSpeed), 
            (ball.dy / ballSpeed), 
            4 * ((computerPaddle.y / canvas.height) - 0.5)
        ]
        // inputs = [1, 1]
        action = brain.forward(inputs);
        computerDistanceFromBall = ((ball.y - computerPaddle.y) / canvas.height)**2
        // console.log(inputs, action)
        // action = brain.forward([ball.x, ball.y, computerPaddle.y]);
        if (action == 1) {
            computerPaddle.y += paddleSpeed;
        } else if (action == 2) {
            computerPaddle.y -= paddleSpeed;
        }
        // Else do nothing 

        if (computerPaddle.y < 0) {
            computerPaddle.y = 0
        } else if (computerPaddle.y + paddleHeight > canvas.height) {
            computerPaddle.y = canvas.height - paddleHeight;
        }

        //
        // Move Ball
        //
        ball.x += ball.dx;
        ball.y += ball.dy;
        // reward = (action == 0) ? 0.5: -0.5 // Penalize twitchy behavior
        reward = 5 * (computerDistanceFromBall - ((ball.y - computerPaddle.y) / canvas.height)**2)
        // console.log(action, reward)
        // console.log("ball", ball.x - ball.radius)

        if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
            ball.dy *= -1;
        }
        if (ball.x - ball.radius < 15) {
            computerScore++;
            updateScore();
            resetBall();
        } else if (ball.x + ball.radius > canvas.width - 15) {
            reward = -10.0 // Negative reward for failing to hit the ball
            playerScore++;
            updateScore();
            resetBall();
        } else if  (ball.x + ball.radius > computerPaddle.x &&
                    ball.y > computerPaddle.y &&
                    ball.y < computerPaddle.y + computerPaddle.height) 
        {
            reward = 10.0; // Reward hitting the ball
            ball.dx *= -1;
        } else if  (ball.x - ball.radius < playerPaddle.x + playerPaddle.width &&
                    ball.y > playerPaddle.y &&
                    ball.y < playerPaddle.y + playerPaddle.height)
        {
            ball.dx *= -1;
        }
        
        brain.backward(reward);

        // updateActionChart();
        if (frame > 1000 && frame % 100 === 0) {
            // console.log(brain.value_net.layers[brain.value_net.layers.length-1].out_act.w.some(Number.isNaN))
            if (brain.value_net.layers[brain.value_net.layers.length-1].out_act.w.some(Number.isNaN)) {
                console.log("ERROR! The array contains NaN values.");
            }
            addData()
        }
        if (frame % 10000 === 0) {
            console.log(brain)
        }
    }

    let playerScore = 0;
    let computerScore = 0;
    const playerScoreElement = document.getElementById("playerScore");
    const computerScoreElement = document.getElementById("computerScore");

    function drawRect(x, y, width, height, color) {
        context.fillStyle = color;
        context.fillRect(x, y, width, height);
    }

    function drawCircle(x, y, radius, color) {
        context.fillStyle = color;
        context.beginPath();
        context.arc(x, y, radius, 0, Math.PI * 2);
        context.closePath();
        context.fill();
    }

    function resetBall() {
        ball.x = canvas.width / 2;
        // Math.random() * (max - min) + min;
        ball.y = Math.random() * (canvas.height - 200) + 100;
        ball.dx *= -1;
    }

    function updateScore() {
        playerScoreElement.textContent = `Player: ${playerScore}`;
        computerScoreElement.textContent = `Computer: ${computerScore}`;
    }

    function draw() {
        context.clearRect(0, 0, canvas.width, canvas.height);
        drawRect(playerPaddle.x, playerPaddle.y, playerPaddle.width, playerPaddle.height, "#FFF");
        drawRect(computerPaddle.x, computerPaddle.y, computerPaddle.width, computerPaddle.height, "#FFF");
        drawCircle(ball.x, ball.y, ball.radius, "#FFF");
    }

    function gameLoop() {
        update();
        draw();
    }

    document.addEventListener("keydown", (event) => {
        if (event.key === "ArrowUp") {
            playerPaddle.dy = -paddleSpeed;
            event.preventDefault();
        } else if (event.key === "ArrowDown") {
            playerPaddle.dy = paddleSpeed;
            event.preventDefault();
        }
    });

    document.addEventListener("keyup", () => {
        playerPaddle.dy = 0;
    });

    canvas.addEventListener('click', () => {
        canvas.focus();
    });

    let gameLoopInterval = setInterval(gameLoop, intervalTime);

    </script>
</html>
